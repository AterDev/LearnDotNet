# 面向对象的概念及思维方式

我们先来看一个`树排序`算法示例，分别用我们之前学到的内容以及使用面向对象思维去实现，来感受一下其中的不同。

以下是使用C语言实现的版本

```c
#include <stdio.h>

// 调整堆，使其满足堆的性质
void heapify(int arr[], int n, int i) {
    int largest = i;    // 初始化largest为根节点
    int left = 2 * i + 1;   // 左子节点
    int right = 2 * i + 2;  // 右子节点

    // 如果左子节点比根节点大，则更新largest
    if (left < n && arr[left] > arr[largest])
        largest = left;

    // 如果右子节点比根节点大，则更新largest
    if (right < n && arr[right] > arr[largest])
        largest = right;

    // 如果largest不是根节点，则交换根节点与largest节点，并递归调整堆
    if (largest != i) {
        int temp = arr[i];
        arr[i] = arr[largest];
        arr[largest] = temp;
        heapify(arr, n, largest);
    }
}

// 堆排序函数
void heapSort(int arr[], int n) {
    // 构建堆（最大堆），从最后一个非叶子节点开始向上调整堆
    for (int i = n / 2 - 1; i >= 0; i--)
        heapify(arr, n, i);

    // 依次取出堆顶元素（最大元素），与末尾元素交换，并重新调整堆
    for (int i = n - 1; i >= 0; i--) {
        int temp = arr[0];
        arr[0] = arr[i];
        arr[i] = temp;

        // 对剩余元素重新调整堆
        heapify(arr, i, 0);
    }
}

// 打印数组函数
void printArray(int arr[], int n) {
    for (int i = 0; i < n; ++i)
        printf("%d ", arr[i]);
    printf("\n");
}

// 主函数
int main() {
    int arr[] = {5, 3, 8, 4, 2, 7, 9, 1, 6};
    int n = sizeof(arr) / sizeof(arr[0]);

    printf("原始数组：\n");
    printArray(arr, n);

    heapSort(arr, n);

    printf("排序后的数组：\n");
    printArray(arr, n);
    return 0;
}
```

再来看一下使用C#，通过定义树型类来实现类似的算法:

```csharp
int[] unsortedArray = { 5, 3, 8, 4, 2, 7, 9, 1, 6 };
int[] sortedArray = TreeSort(unsortedArray);
Console.WriteLine("原数组: " + string.Join(", ", unsortedArray));
Console.WriteLine("排序后数组: " + string.Join(", ", sortedArray));


static int[] TreeSort(int[] array)
{
    if (array == null || array.Length == 0)
        return array;

    TreeNode root = null;

    // 构建二叉搜索树
    foreach (int value in array)
    {
        root = Insert(root, value);
    }

    // 中序遍历二叉搜索树并获取排序后的元素
    List<int> sortedList = new List<int>();
    InOrderTraversal(root, sortedList);

    return sortedList.ToArray();
}


static TreeNode Insert(TreeNode node, int value)
{
    if (node == null)
        return new TreeNode(value);

    if (value < node.Value)
    {
        node.Left = Insert(node.Left, value);
    }
    else
    {
        node.Right = Insert(node.Right, value);
    }
    return node;
}

static void InOrderTraversal(TreeNode node, List<int> result)
{
    if (node == null)
        return;

    InOrderTraversal(node.Left, result);
    result.Add(node.Value);
    InOrderTraversal(node.Right, result);
}


public class TreeNode
{
    public int Value;
    public TreeNode Left;
    public TreeNode Right;

    public TreeNode(int value)
    {
        Value = value;
        Left = null;
        Right = null;
    }
}
```

当然，在实际编程中，对于排序这种常见的需求，我们当然不需要自己去实现，很多类库在内部已经实现了这些功能。

所以，如果是面向实际业务，我们的代码应该是这样的：

```csharp
int[] unsortedArray = { 5, 3, 8, 4, 2, 7, 9, 1, 6 };
// 使用 SortedSet 插入元素并自动排序
var sortedSet = new SortedSet<int>(unsortedArray);
Console.WriteLine("排序后:" + string.Join(",", sortedSet.ToArray()));
```

或者直接使用Linq的OrderBy方法：

```csharp
int[] unsortedArray = { 5, 3, 8, 4, 2, 7, 9, 1, 6 };
var sortedArray = unsortedArray.OrderBy(x => x).ToArray();
Console.WriteLine("排序后:" + string.Join(",", sortedArray));
```

面向对象一句话概括就是：编程语言使用类的方式来抽象和表达事务。

那么类有什么神奇的地方，能够抽象万物呢？

我们先来模拟一下人类是如何抽象和定义事物的：

- 定义动物是什么： 有生命，有感觉，有呼吸，有繁殖能力
- 定义狗是什么： 有生命，有感觉，有呼吸，有繁殖能力，有四条腿，有尾巴，有毛发
- 定义什么是汽车： 有四个轮子，有发动机，有车门，有车窗
- 定义香蕉： 形状，颜色，味道

将事物具有什么样的属性，有什么样的行为，这就是抽象的过程。
